# Cap√≠tulo 6: Almacenamiento de datos en estructuras de datos.
## üóÉÔ∏è Array
En Motoko, una matriz de tipo `Array` es un grupo de elementos **similares** (es decir, del mismo tipo) que se almacenan juntos. Para crear una matriz, se debe especificar los tipos de elementos que la matriz contendr√°. 
Por ejemplo, as√≠ es como se crea una matriz que contendr√° `Nat`.
```motoko
let ages : [Nat] = [16, 32, 25, 8, 89];
```
Un arreglo que guarde valores de tipo `Text`.
```motoko
let words : [Text] = ["Motoko", "is", "the", "best", "language"];
```
Contrario a otros lenguajes de programaci√≥n que pueden ser m√°s flexibles en ese sentido, en Motoko no podemos mezclar elementos de diferentes tipos en el mismo array. <br/>
El siguiente c√≥digo generar√° un error: `literal of type Text does not have expected type Nat`. 
```motoko
let array : [Nat] = [14, 16, 32, 25, "Motoko"];
```
<p align="center"> <img src="assets/array.png" width="600px" style="border: 2px solid black;"></p>
Para acceder a un elemento espec√≠fico dentro de un array, usamos su √≠ndice. Tenga en cuenta que los arrays en Motoko comienzan en cero, lo que significa que el primer elemento est√° en la posici√≥n 0, el segundo elemento est√° en la posici√≥n 1, y as√≠ sucesivamente. Por ejemplo, para acceder al primer elemento de un array llamado `myArray`, usar√≠amos `myArray[0]`, y para acceder al segundo elemento, usar√≠amos `myArray[1]`.
```motoko
let myArray : [Nat] = [23, 16, 32, 25];
let a = myArray[0]  // 23
let b = myArray[3]  // 25
```
Podemos acceder al tama√±o de un array usando el m√©todo `.size()`.

```motoko
let names : [Text] = ["Emma Smith", "Olivia Johnson", "Ava Brown", "Isabella Davis"];
let size = names.size();    // 4
```

Para iterar sobre un array, podemos usar el iterador `.vals()`. Aqu√≠ hay un ejemplo que nos dar√≠a la suma de un array.
```motoko
actor {
    let array : [Nat] = [1, 2, 3, 4, 5];
    var sum : Nat = 0;

    public func somme_array() : async Nat {
        for (value in array.vals()){
          sum := sum + value;
        };
       return sum; 
    };
};
```

En Motoko, los arrays tienen un tama√±o fijo que se determina cuando se crea el array. Esto significa que el tama√±o no se puede aumentar m√°s tarde. Para agregar un nuevo elemento a un array, se debe crear un nuevo array y transferir manualmente todos los elementos existentes al nuevo array. Esto hace que `Array` no sea realmente adecuado para estructuras de datos que necesiten ser actualizadas constantemente.

La concatenaci√≥n de dos arrays en un `Array` se puede hacer usando `Array.append()` - una funci√≥n del m√≥dulo [Array](https://internetcomputer.org/docs/current/motoko/main/base/Array). 
```motoko
let array1 = [1, 2, 3];
let array2 = [4, 5, 6];
Array.append<Nat>(array1, array2) // [1, 2, 3, 4, 5, 6];
```
Sin embargo, esta funci√≥n est√° **obsoleta**. Se recomienda evitarla en el c√≥digo de producci√≥n. Esto se debe a que, como mencionamos anteriormente, es imposible simplemente agregar elementos a un array. En realidad, `Array.append()` crear√° un nuevo array y copiar√° los valores de los dos arrays existentes, lo cual no es eficiente.

## ü•û Buffer
Una estructura m√°s adecuada para agregar din√°micamente nuevos elementos es el tipo `Buffer`. 
Un `Buffer` se puede instanciar utilizando la biblioteca [Buffer](https://internetcomputer.org/docs/current/motoko/main/base/Buffer). 
Es necesario proporcionar los tipos de elementos almacenados en el interior y la capacidad inicial. 
La capacidad inicial representa la longitud del array subyacente que respalda esta lista. En la mayor√≠a de los casos, no tendr√° que preocuparse por la `capacity` ya que el Buffer autom√°ticamente crecer√° o cambiar√° el tama√±o del array subyacente que contiene los elementos.
```motoko
import Buffer "mo:base/Buffer";
actor {
    let b = Buffer.Buffer<Nat>(2);
}
```
En este caso, los tipos de elementos en el buffer son de type `Nat` y la capacidad inicial del buffer es `2`. 

Para agregar un elemento utilizar el m√©todo `.add()`.
```motoko
b.add(0);   // add 0 to buffer
b.add(10);   // add 10 to buffer
b.add(100)    // causes underlying arrray to increase in capacity since the capacity was set to 2
```
Para obtener el n√∫mero de elementos en el buffer utilizar el m√©todo `.size()`. El `size` es diferente que la capacidad que mencionamos antes dado que representa el n√∫mero de elementos que realmente est√°n almacenados en el buffer.
```motoko
let b = Buffer.Buffer<Nat>(2);
b.add(0);   
b.add(10);   
b.add(100);  
b.size();   // 3
```
Para acceder a elementos en el buffer, utiliza el m√©todo `.get()` e indica el √≠ndice. Traps si `index` >= `size`. El √≠ndice se inicio en cero como el `Array`.
```motoko
let b = Buffer.Buffer<Nat>(2);
b.add(0);   
b.add(10);   
b.add(100);  
b.get(2);   // 10
```

Un buffer puedes facilmente ser convertido en un array utilizando la funci√≥n `toArray()`  de la [Librer√≠a Buffer](https://internetcomputer.org/docs/current/motoko/main/base/Buffer#function-toarray-1).
```motoko
let b = Buffer.Buffer<Nat>(2);
b.add(0);   
b.add(10);   
Buffer.toArray<Nat>(b); // [0, 10];
```
## üîó List
Una lista de tipo List<T> es una lista enlazada que es o nula o una pareja opcional de un valor de tipo T y una cola, que es a su vez de tipo List<T>.

[Librer√≠a List](https://internetcomputer.org/docs/current/motoko/main/base/List/)

```motoko
type List<T> = ?(T, List<T>);
```
```
"La diferencia entre una lista y un arreglo es que un arreglo se almacena como un bloque continuo de bytes en memoria y una lista est√° 'esparcida' sin que los elementos tengan que estar juntos. La ventaja es que podemos usar la memoria de manera m√°s eficiente llenando la memoria de manera m√°s flexible. El inconveniente es que para operaciones en toda la lista, tenemos que visitar cada elemento uno por uno, lo que puede ser computacionalmente costoso." -(fuente)[https://web3.motoko-book.dev/base-library/data-structures/list.html]
Lee sobre listas y tipos recursivos aqu√≠.

Aqu√≠ tienes un ejemplo de una funci√≥n que recupera el √∫ltimo elemento de una lista en particular.
```motoko
func last<T>(l : List<T>) : ?T {
    switch l {
        case null { null };
        case (?(x, null)) { ?x };
        case (?(_, t)) { last<T>(t) };
    };
};
```

## üíø HashMap y TrieMap
En Motoko, [HashMap](https://internetcomputer.org/docs/current/references/motoko-ref/HashMap) y [TrieMap](https://internetcomputer.org/docs/current/references/motoko-ref/HashMap) se implementan como una clase y tienen la misma interfaz. La √∫nica diferencia es que `TrieMap` se representa internamente como un `Trie`, mientras que `HashMap` utiliza `AssocList`. Todos los ejemplos que seguir√°n usar√°n `HashMap`, pero ser√≠a similar para `TrieMap`.

- K es el tipo de la clave (`Nat`, `Text`, `Principal`...)
- V es el tipo del valor que se almacenar√° (Datos de usuario, saldo de tokens...)

```motoko
class HashMap<K, V>(initCapacity : Nat, keyEq : (K, K) -> Bool, keyHash : K -> Hash.Hash)
```

Para instanciar un valor de la clase, necesitamos proporcionar:
1. Una capacidad inicial de tipo `Nat`.
    ```motoko
    initCapacity : Nat
    ```
2. Una funci√≥n que se pueda utilizar para probar la igualdad de las claves.
    ```motoko
    keyEq : (K, K) -> Bool
    ```
3. Una funci√≥n que se pueda utilizar para el hash de las claves.
    ```motoko
    keyHash : K -> Hash.Hash
    ```

Imaginemos que queremos almacenar un `Estudiante` asociado con su `Principal`. Donde `Estudiante` est√° definido como:```motoko
type Student = {
    name : Text;
    age : Nat;
    favoriteLanguage : Text;
    graduate : Bool;
};
```

En ese caso:
- K es de tipo `Principal` y representa la clave del HashMap.
- V es de tipo `User` y representa el valor almacenado.

Para iniciar nuestro `HashMap`, podemos hacer lo siguiente:
```motoko
import HashMap "mo:base/HashMap";
import Principal "mo:base/Principal";
actor {
    type Student = {
        name : Text;
        age : Nat;
        favoriteLanguage : Text;
        graduate : Bool;
    };

    let map = HashMap.HashMap<Principal, Student>(1, Principal.equal, Principal.hash);
}
```
Para agregar una nueva entrada al `map`, podemos usar el m√©todo `.put()`.
  
```motoko
map.put(principal, student);
```
Esto insertar√° el valor `student` con la clave `principal` y sobrescribir√° cualquier valor anterior. Podemos usar este m√©todo para crear una funci√≥n `register` que los estudiantes tendr√≠an que llamar y proporcionar toda su informaci√≥n relevante.

```motoko
public shared ({ caller }) func register(name : Text, age : Nat, favoriteLanguage : Text) : async () {
    if(Principal.isAnonymous(caller)){
        // We don't want to register the anonymous identity
        return;
    };
    let student : Student = {
        name;
        age;
        favoriteLanguage;
        graduate = false;  
    };
    map.put(caller, student);
};
```

Una vez que se ha insertado un valor en el `map`, podemos acceder a √©l utilizando el m√©todo `.get()`.
```motoko
map.get(principal);
```
Esto devolver√° un valor opcional `?Student` asociado con el `principal` proporcionado. Podemos usar este m√©todo para crear una funci√≥n de consulta `getStudent` que devolver√≠a informaci√≥n sobre los estudiantes.
```motoko
public query func getStudent(p : Principal) : async ?Student {
map.get(p);
};
```
Podemos eliminar un valor del `map` utilizando los m√©todos `.delete()` o `remove()`.
```motoko
map.delete(principal);   // Delete but doesn't return the value
let oldValue = map.remove(principal);   // Delete but returns the value
```
Es posible iterar sobre el mapa:
- Puede iterar sobre las claves con `.keys()`.
- Puede iterar sobre los valores con `.vals()`.
- Puede iterar sobre ambos con `.entries()`.
